<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>【面试】后端面试题集02 - Begi</title><meta name=author content="Kendrick"><meta name=author-link content="https://kendrickcheung.github.io/"><meta name=description content="注意 本文内容来源于：【Github】后端面试题集 🎆 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁? Go中的三种锁包括:互"><meta name=keywords content="interview,Golang"><meta itemprop=name content="【面试】后端面试题集02"><meta itemprop=description content="注意 本文内容来源于：【Github】后端面试题集 🎆 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁? Go中的三种锁包括:互"><meta itemprop=datePublished content="2022-10-16T15:55:37+08:00"><meta itemprop=dateModified content="2022-11-07T01:50:47+00:00"><meta itemprop=wordCount content="4673"><meta itemprop=image content="https://kendrickcheung.github.io/logo.png"><meta itemprop=keywords content="interview,Golang,"><meta property="og:title" content="【面试】后端面试题集02"><meta property="og:description" content="注意 本文内容来源于：【Github】后端面试题集 🎆 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁? Go中的三种锁包括:互"><meta property="og:type" content="article"><meta property="og:url" content="https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/"><meta property="og:image" content="https://kendrickcheung.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-16T15:55:37+08:00"><meta property="article:modified_time" content="2022-11-07T01:50:47+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kendrickcheung.github.io/logo.png"><meta name=twitter:title content="【面试】后端面试题集02"><meta name=twitter:description content="注意 本文内容来源于：【Github】后端面试题集 🎆 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁? Go中的三种锁包括:互"><meta name=application-name content="Begi"><meta name=apple-mobile-web-app-title content="Begi"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=lamb.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/><link rel=prev href=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8601/><link rel=next href=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8603/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【面试】后端面试题集02","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/kendrickcheung.github.io\/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602\/"},"image":[{"@type":"ImageObject","url":"https:\/\/kendrickcheung.github.io\/images\/Apple-Devices-Preview.jpg","width":1842,"height":1036}],"genre":"posts","keywords":"interview, Golang","wordcount":4673,"url":"https:\/\/kendrickcheung.github.io\/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602\/","datePublished":"2022-10-16T15:55:37+08:00","dateModified":"2022-11-07T01:50:47+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"Kendrick","logo":{"@type":"ImageObject","url":"https:\/\/kendrickcheung.github.io\/images\/study-avatar.png","width":1024,"height":1024}},"author":{"@type":"Person","name":"Kendrick"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=Begi><img class="lazyload logo" src=/svg/loading.min.svg data-src=/lamb.svg data-srcset="/lamb.svg, /lamb.svg 1.5x, /lamb.svg 2x" data-sizes=auto alt=Begi title=Begi><span class=header-title-text>Begi</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=Begi><img class="lazyload logo" src=/svg/loading.min.svg data-src=/lamb.svg data-srcset="/lamb.svg, /lamb.svg 1.5x, /lamb.svg 2x" data-sizes=auto alt=/lamb.svg title=/lamb.svg><span class=header-title-text>Begi</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/kendrickcheung/begi title=GitHub rel="noopener noreferrer" target=_blank><i class='fa-brands fa-github fa-fw' aria-hidden=true></i></a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li><li class="menu-item language"><span role=button aria-label=选择语言 title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container data-page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom id=aside-sakana><div class=sakana-widget><div class=sakana-item id=takina-widget></div><div class=sakana-item id=chisato-widget></div></div><script>function initSakanaWidget(){const e=SakanaWidget.getCharacter("takina");SakanaWidget.registerCharacter("takina-slow",e),new SakanaWidget({character:"takina-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#takina-widget");const t=SakanaWidget.getCharacter("chisato");SakanaWidget.registerCharacter("chisato-slow",t),new SakanaWidget({character:"chisato-slow",controls:!1,autoFit:!0,stroke:{color:"#b4b4b4",width:2}}).mount("#chisato-widget")}</script><script async onload=initSakanaWidget() src=https://cdn.jsdelivr.net/npm/sakana-widget@2.3.0/lib/sakana.min.js></script></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>【面试】后端面试题集02</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://kendrickcheung.github.io/ title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img class="lazyload avatar" src=/svg/loading.min.svg data-src="https://gravatar.loli.net/avatar/cc632f71644a401f82ae230dd3fd84ce?s=32&d=mp" data-srcset="https://gravatar.loli.net/avatar/cc632f71644a401f82ae230dd3fd84ce?s=32&d=mp, https://gravatar.loli.net/avatar/cc632f71644a401f82ae230dd3fd84ce?s=32&d=mp 1.5x, https://gravatar.loli.net/avatar/cc632f71644a401f82ae230dd3fd84ce?s=32&d=mp 2x" data-sizes=auto alt=Kendrick title=Kendrick>&nbsp;Kendrick</a></span>
<span class=post-category>收录于 <a href=/categories/programming/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;编程</a></span></div><div class=post-meta-line><span title="2022-10-16 15:55:37"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-10-16>2022-10-16</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 4673 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 10 分钟&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=【面试】后端面试题集02>
<i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#-说下go中的锁有哪些三种锁读写锁互斥锁还有map的安全的锁>🎆 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁?</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文内容来源于：<a href=https://github.com/xiaobaiTech/golangFamily target=_blank rel="external nofollow noopener noreferrer">【Github】后端面试题集<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></div></div></div><h4 id=-说下go中的锁有哪些三种锁读写锁互斥锁还有map的安全的锁>🎆 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁?</h4><p><em>Go中的三种锁包括:互斥锁,读写锁,sync.Map的安全的锁.</em></p><p><strong>互斥锁</strong></p><p>Go并发程序对共享资源进⾏访问控制的主要⼿段，由标准库代码包中sync中的Mutex结构体表示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//Mutex 是互斥锁， 零值是解锁的互斥锁， ⾸次使⽤后不得复制互斥锁。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Mutex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>state</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl> <span class=nx>sema</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><em>sync.Mutex包中的类型只有两个公开的指针⽅法Lock和Unlock。</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//Locker表示可以锁定和解锁的对象。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Locker</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//锁定当前的互斥量
</span></span></span><span class=line><span class=cl><span class=c1>//如果锁已被使⽤，则调⽤goroutine
</span></span></span><span class=line><span class=cl><span class=c1>//阻塞直到互斥锁可⽤。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//对当前互斥量进⾏解锁
</span></span></span><span class=line><span class=cl><span class=c1>//如果在进⼊解锁时未锁定m，则为运⾏时错误。
</span></span></span><span class=line><span class=cl><span class=c1>//锁定的互斥锁与特定的goroutine⽆关。
</span></span></span><span class=line><span class=cl><span class=c1>//允许⼀个goroutine锁定Mutex然后安排另⼀个goroutine来解锁它。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Mutex</span><span class=p>)</span> <span class=nf>Unlock</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><hr><p><strong>声明⼀个互斥锁：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>mutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span></code></pre></td></tr></table></div></div><p>不像C或Java的锁类⼯具，我们可能会犯⼀个错误：忘记及时解开已被锁住的锁，从⽽导致流程异常。但Go由于存在defer，所以此类问题出现的概率极低。关于defer解锁的⽅式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>mutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Write</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=k>defer</span> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果对⼀个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>ort</span> <span class=p>(</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=kd>var</span> <span class=nx>mutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin lock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;get locked&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin lock &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;get locked &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Unlock the lock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;get unlocked&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们在for循环之前开始加锁，然后在每⼀次循环中创建⼀个协程，并对其加锁，但是由于之前已经加锁了，所以这个for循环中的加锁会陷⼊阻塞直到main中的锁被解锁， time.Sleep(time.Second) 是为了能让系统有⾜够的时间运⾏for循环，输出结果如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt; go run mutex.go
</span></span><span class=line><span class=cl>begin lock
</span></span><span class=line><span class=cl>get locked
</span></span><span class=line><span class=cl>begin lock <span class=m>3</span>
</span></span><span class=line><span class=cl>begin lock <span class=m>1</span>
</span></span><span class=line><span class=cl>begin lock <span class=m>2</span>
</span></span><span class=line><span class=cl>Unlock the lock
</span></span><span class=line><span class=cl>get unlocked
</span></span><span class=line><span class=cl>get locked <span class=m>3</span>
</span></span></code></pre></td></tr></table></div></div><p>这⾥可以看到解锁后，三个协程会重新抢夺互斥锁权，最终协程3获胜。</p><p>互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发⼀个⽆法恢复的运⾏时的panic，⽐如对⼀个未锁定的互斥锁进⾏解锁时就会发⽣panic。避免这种情况的最有效⽅式就是使⽤defer。</p><p>我们知道如果遇到panic，可以使⽤recover⽅法进⾏恢复，但是如果对重复解锁互斥锁引发的panic却是⽆⽤的（Go 1.8及以后）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Try to recover the panic&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=nx>p</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span> <span class=nx>p</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;recover the panic : &#34;</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}()</span>
</span></span><span class=line><span class=cl> <span class=kd>var</span> <span class=nx>mutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;begin lock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;get locked&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;unlock lock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;lock is unlocked&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;unlock lock again&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>运⾏:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt; go run mutex.go
</span></span><span class=line><span class=cl>begin lock
</span></span><span class=line><span class=cl>get locked
</span></span><span class=line><span class=cl>unlock lock
</span></span><span class=line><span class=cl>l error: sync: unlock of unlocked mutex
</span></span><span class=line><span class=cl>goroutine <span class=m>1</span> <span class=o>[</span>running<span class=o>]</span>:
</span></span><span class=line><span class=cl>runtime.throw<span class=o>(</span>0x4bc1a8, 0x1e<span class=o>)</span>
</span></span><span class=line><span class=cl> /home/keke/soft/go/src/runtime/panic.go:617 +0x72 <span class=nv>fp</span><span class=o>=</span>0xc000084ea8
</span></span><span class=line><span class=cl><span class=nv>sp</span><span class=o>=</span>0xc000084e78 <span class=nv>pc</span><span class=o>=</span>0x427ba2
</span></span><span class=line><span class=cl>sync.throw<span class=o>(</span>0x4bc1a8, 0x1e<span class=o>)</span>
</span></span><span class=line><span class=cl> /home/keke/soft/go/src/runtime/panic.go:603 +0x35 <span class=nv>fp</span><span class=o>=</span>0xc000084ec8
</span></span><span class=line><span class=cl><span class=nv>sp</span><span class=o>=</span>0xc000084ea8 <span class=nv>pc</span><span class=o>=</span>0x427b25
</span></span><span class=line><span class=cl>sync.<span class=o>(</span>*Mutex<span class=o>)</span>.Unlock<span class=o>(</span>0xc00001a0c8<span class=o>)</span>
</span></span><span class=line><span class=cl> /home/keke/soft/go/src/sync/mutex.go:184 +0xc1 <span class=nv>fp</span><span class=o>=</span>0xc000084ef0 <span class=nv>sp</span><span class=o>=</span>0xc000084ec8
</span></span><span class=line><span class=cl><span class=nv>pc</span><span class=o>=</span>0x45f821
</span></span><span class=line><span class=cl>main.main<span class=o>()</span>
</span></span><span class=line><span class=cl> /home/keke/go/Test/mutex.go:25 +0x25f <span class=nv>fp</span><span class=o>=</span>0xc000084f98 <span class=nv>sp</span><span class=o>=</span>0xc000084ef0
</span></span><span class=line><span class=cl><span class=nv>pc</span><span class=o>=</span>0x486c1f
</span></span><span class=line><span class=cl>runtime.main<span class=o>()</span>
</span></span><span class=line><span class=cl> /home/keke/soft/go/src/runtime/proc.go:200 +0x20c <span class=nv>fp</span><span class=o>=</span>0xc000084fe0
</span></span><span class=line><span class=cl><span class=nv>sp</span><span class=o>=</span>0xc000084f98 <span class=nv>pc</span><span class=o>=</span>0x4294ec
</span></span><span class=line><span class=cl>runtime.goexit<span class=o>()</span>
</span></span><span class=line><span class=cl> /home/keke/soft/go/src/runtime/asm_amd64.s:1337 +0x1 <span class=nv>fp</span><span class=o>=</span>0xc000084fe8
</span></span><span class=line><span class=cl><span class=nv>sp</span><span class=o>=</span>0xc000084fe0 <span class=nv>pc</span><span class=o>=</span>0x450ad1
</span></span><span class=line><span class=cl><span class=nb>exit</span> status <span class=m>2</span>
</span></span></code></pre></td></tr></table></div></div><p>这⾥试图对重复解锁引发的panic进⾏recover，但是我们发现操作失败，虽然互斥锁可以被多个协程共享，但还是建议将对同⼀个互斥锁的加锁解锁操作放在同⼀个层次的代码中。</p><p><strong>读写锁</strong>
读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进⾏锁定和解锁操作 。</p><p><strong>读写锁的访问控制规则如下：</strong></p><ol><li>多个写操作之间是互斥的</li><li>写操作与读操作之间也是互斥的</li><li>多个读操作之间不是互斥的</li></ol><p>在这样的控制规则下，读写锁可以⼤⼤降低性能损耗。</p><p>在Go的标准库代码包中sync中的RWMutex结构体表示为:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// RWMutex是⼀个读/写互斥锁，可以由任意数量的读操作或单个写操作持有。
</span></span></span><span class=line><span class=cl><span class=c1>// RWMutex的零值是未锁定的互斥锁。
</span></span></span><span class=line><span class=cl><span class=c1>//⾸次使⽤后，不得复制RWMutex。
</span></span></span><span class=line><span class=cl><span class=c1>//如果goroutine持有RWMutex进⾏读取⽽另⼀个goroutine可能会调⽤Lock，那么在释放初始读锁之前，
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>goroutine不应该期望能够获取读锁定</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=c1>//特别是，这种禁⽌递归读锁定。 这是为了确保锁最终变得可⽤; 阻⽌的锁定会阻⽌新读操作获取锁定。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>RWMutex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>w</span> <span class=nx>Mutex</span> <span class=c1>//如果有待处理的写操作就持有
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>writerSem</span> <span class=kt>uint32</span> <span class=c1>// 写操作等待读操作完成的信号量
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>readerSem</span> <span class=kt>uint32</span> <span class=c1>//读操作等待写操作完成的信号量
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>readerCount</span> <span class=kt>int32</span> <span class=c1>// 待处理的读操作数量
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>readerWait</span> <span class=kt>int32</span> <span class=c1>// number of departing readers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>sync中的RWMutex有以下⼏种⽅法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//对读操作的锁定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rw</span> <span class=o>*</span><span class=nx>RWMutex</span><span class=p>)</span> <span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//对读操作的解锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rw</span> <span class=o>*</span><span class=nx>RWMutex</span><span class=p>)</span> <span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//对写操作的锁定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rw</span> <span class=o>*</span><span class=nx>RWMutex</span><span class=p>)</span> <span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//对写操作的解锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rw</span> <span class=o>*</span><span class=nx>RWMutex</span><span class=p>)</span> <span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//返回⼀个实现了sync.Locker接⼝类型的值，实际上是回调rw.RLock and rw.RUnlock.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rw</span> <span class=o>*</span><span class=nx>RWMutex</span><span class=p>)</span> <span class=nf>RLocker</span><span class=p>()</span> <span class=nx>Locker</span>
</span></span></code></pre></td></tr></table></div></div><p>Unlock⽅法会试图唤醒所有想进⾏读锁定⽽被阻塞的协程，⽽ RUnlock⽅法只会在已⽆任何读锁定的情况下，试图唤醒⼀个因欲进⾏写锁定⽽被阻塞的协程。若对⼀个未被写锁定的读写锁进⾏写解锁，就会引发⼀个不可恢复的panic，同理对⼀个未被读锁定的读写锁进⾏读写锁也会如此。</p><p>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同⼀个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进⾏操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=kd>var</span> <span class=nx>rwm</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl> <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;try to lock read &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>rwm</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;get locked &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;try to unlock for reading &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>rwm</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;unlocked for reading &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;try to lock for writing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>rwm</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;locked for writing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>运⾏:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&gt; go run rwmutex.go
</span></span><span class=line><span class=cl>try to lock <span class=nb>read</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>get locked <span class=m>0</span>
</span></span><span class=line><span class=cl>try to lock <span class=nb>read</span> <span class=m>4</span>
</span></span><span class=line><span class=cl>get locked <span class=m>4</span>
</span></span><span class=line><span class=cl>try to lock <span class=nb>read</span> <span class=m>3</span>
</span></span><span class=line><span class=cl>get locked <span class=m>3</span>
</span></span><span class=line><span class=cl>try to lock <span class=nb>read</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>get locked <span class=m>1</span>
</span></span><span class=line><span class=cl>try to lock <span class=nb>read</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>get locked <span class=m>2</span>
</span></span><span class=line><span class=cl>try to lock <span class=k>for</span> writing
</span></span><span class=line><span class=cl>try to unlock <span class=k>for</span> reading <span class=m>0</span>
</span></span><span class=line><span class=cl>unlocked <span class=k>for</span> reading <span class=m>0</span>
</span></span><span class=line><span class=cl>try to unlock <span class=k>for</span> reading <span class=m>2</span>
</span></span><span class=line><span class=cl>unlocked <span class=k>for</span> reading <span class=m>2</span>
</span></span><span class=line><span class=cl>try to unlock <span class=k>for</span> reading <span class=m>1</span>
</span></span><span class=line><span class=cl>unlocked <span class=k>for</span> reading <span class=m>1</span>
</span></span><span class=line><span class=cl>try to unlock <span class=k>for</span> reading <span class=m>3</span>
</span></span><span class=line><span class=cl>unlocked <span class=k>for</span> reading <span class=m>3</span>
</span></span><span class=line><span class=cl>try to unlock <span class=k>for</span> reading <span class=m>4</span>
</span></span><span class=line><span class=cl>unlocked <span class=k>for</span> reading <span class=m>4</span>
</span></span><span class=line><span class=cl>locked <span class=k>for</span> writing
</span></span></code></pre></td></tr></table></div></div><p>这⾥可以看到创建了五个协程⽤于对读写锁的读锁定与读解锁操作。在 rwm.Lock()种会对main中协程进⾏写锁定，但是for循环中的读解锁尚未完成，因此会造成mian中的协程阻塞。当for循环中的读解锁操作都完成后就会试图唤醒main中阻塞的协程，main中的写锁定才会完成。</p><p><strong>sync.Map安全锁</strong></p><p>golang中的sync.Map是并发安全的，其实也就是sync包中golang⾃定义的⼀个名叫Map的结构体。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>//开箱即⽤
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=kd>var</span> <span class=nx>sm</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span>
</span></span><span class=line><span class=cl> <span class=c1>//store ⽅法,添加元素
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>sm</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=s>&#34;a&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=c1>//Load ⽅法，获得value
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=k>if</span> <span class=nx>v</span><span class=p>,</span><span class=nx>ok</span><span class=o>:=</span><span class=nx>sm</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=nx>ok</span><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=c1>//LoadOrStore⽅法，获取或者保存
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=c1>//参数是⼀对key：value，如果该key存在且没有被标记删除则返回原先的value（不更新）和true；不存在则
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>store</span><span class=err>，</span><span class=nx>返回该value</span> <span class=nx>和false</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=nx>vv</span><span class=p>,</span><span class=nx>ok</span><span class=o>:=</span><span class=nx>sm</span><span class=p>.</span><span class=nf>LoadOrStore</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=s>&#34;c&#34;</span><span class=p>);</span><span class=nx>ok</span><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>vv</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=nx>vv</span><span class=p>,</span><span class=nx>ok</span><span class=o>:=</span><span class=nx>sm</span><span class=p>.</span><span class=nf>LoadOrStore</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=s>&#34;c&#34;</span><span class=p>);!</span><span class=nx>ok</span><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>vv</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=c1>//遍历该map，参数是个函数，该函数参的两个参数是遍历获得的key和value，返回⼀个bool值，当返回false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>时</span><span class=err>，</span><span class=nx>遍历</span><span class=err>⽴</span><span class=nx>刻结束</span><span class=err>。</span>
</span></span><span class=line><span class=cl> <span class=nx>sm</span><span class=p>.</span><span class=nf>Range</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span><span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span><span class=kt>bool</span><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>运⾏ :</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>a
</span></span><span class=line><span class=cl>a
</span></span><span class=line><span class=cl>c
</span></span><span class=line><span class=cl>1:a
</span></span><span class=line><span class=cl>2:c
</span></span></code></pre></td></tr></table></div></div><p><strong>sync.Map的数据结构:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Map</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>// 该锁⽤来保护dirty
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>mu</span> <span class=nx>Mutex</span>
</span></span><span class=line><span class=cl> <span class=c1>// 存读的数据，因为是atomic.value类型，只读类型，所以它的读是并发安全的
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>read</span> <span class=nx>atomic</span><span class=p>.</span><span class=nx>Value</span> <span class=c1>// readOnly
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=c1>//包含最新的写⼊的数据，并且在写的时候，会把read 中未被删除的数据拷⻉到该dirty中，因为是普通的map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>存在并发安全问题</span><span class=err>，</span><span class=nx>需要</span><span class=err>⽤</span><span class=nx>到上</span><span class=err>⾯</span><span class=nx>的mu字段</span><span class=err>。</span>
</span></span><span class=line><span class=cl> <span class=nx>dirty</span> <span class=kd>map</span><span class=p>[</span><span class=kd>interface</span><span class=p>{}]</span><span class=o>*</span><span class=nx>entry</span>
</span></span><span class=line><span class=cl> <span class=c1>// 从read读数据的时候，会将该字段+1，当等于len（dirty）的时候，会将dirty拷⻉到read中（从⽽提升
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>读的性能</span><span class=err>）。</span>
</span></span><span class=line><span class=cl> <span class=nx>misses</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>read的数据结构是：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>readOnly</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kd>interface</span><span class=p>{}]</span><span class=o>*</span><span class=nx>entry</span>
</span></span><span class=line><span class=cl> <span class=c1>// 如果Map.dirty的数据和m 中的数据不⼀样是为true
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>amended</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>entry的数据结构：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>entry</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>//可⻅value是个指针类型，虽然read和dirty存在冗余情况（amended=false），但是由于是指针类型，存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>储的空间应该不是问题</span>
</span></span><span class=line><span class=cl> <span class=nx>p</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// *interface{}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Delete ⽅法:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>read</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=nx>readOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=c1>//如果read中没有，并且dirty中有新元素，那么就去dirty中去找
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>read</span><span class=p>.</span><span class=nx>amended</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=c1>//这是双检查（上⾯的if判断和锁不是⼀个原⼦性操作）
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>read</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=nx>readOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=p>=</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>read</span><span class=p>.</span><span class=nx>amended</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>//直接删除
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>//如果read中存在该key，则将该value 赋值nil（采⽤标记的⽅式删除！）
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>e</span><span class=p>.</span><span class=nb>delete</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>entry</span><span class=p>)</span> <span class=nb>delete</span><span class=p>()</span> <span class=p>(</span><span class=nx>hadValue</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>p</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>p</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>p</span> <span class=o>==</span> <span class=nx>expunged</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>,</span> <span class=nx>p</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Store ⽅法:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Store</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果m.read存在这个key，并且没有被标记删除，则尝试更新。
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>read</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=nx>readOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span><span class=p>.</span><span class=nf>tryStore</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=c1>// 如果read不存在或者已经被标记删除
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=nx>read</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=nx>readOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//如果entry被标记expunge，则表明dirty没有key，可添加⼊dirty，并更新entry
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nf>unexpungeLocked</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//加⼊dirty中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>e</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//更新value值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>e</span><span class=p>.</span><span class=nf>storeLocked</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=c1>//dirty 存在该key，更新
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>e</span><span class=p>.</span><span class=nf>storeLocked</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=c1>//read 和dirty都没有，新添加⼀条
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//dirty中没有新的数据，往dirty中增加第⼀个新键
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>!</span><span class=nx>read</span><span class=p>.</span><span class=nx>amended</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//将read中未删除的数据加⼊到dirty中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>m</span><span class=p>.</span><span class=nf>dirtyLocked</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>readOnly</span><span class=p>{</span><span class=nx>m</span><span class=p>:</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>,</span> <span class=nx>amended</span><span class=p>:</span> <span class=kc>true</span><span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nf>newEntry</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//将read中未删除的数据加⼊到dirty中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>dirtyLocked</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=nx>read</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=nx>readOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kd>interface</span><span class=p>{}]</span><span class=o>*</span><span class=nx>entry</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>))</span>
</span></span><span class=line><span class=cl> <span class=c1>//read如果较⼤的话，可能影响性能
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>e</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//通过此次操作，dirty中的元素都是未被删除的，可⻅expunge的元素不在dirty中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>!</span><span class=nx>e</span><span class=p>.</span><span class=nf>tryExpungeLocked</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>e</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//判断entry是否被标记删除，并且将标记为nil的entry更新标记为expunge
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>entry</span><span class=p>)</span> <span class=nf>tryExpungeLocked</span><span class=p>()</span> <span class=p>(</span><span class=nx>isExpunged</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>p</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=k>for</span> <span class=nx>p</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>// 将已经删除标记为nil的数据标记为expunged
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>expunged</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=nx>p</span> <span class=p>=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=nx>p</span> <span class=o>==</span> <span class=nx>expunged</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//对entry 尝试更新
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>entry</span><span class=p>)</span> <span class=nf>tryStore</span><span class=p>(</span><span class=nx>i</span> <span class=o>*</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>p</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>p</span> <span class=o>==</span> <span class=nx>expunged</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>,</span> <span class=nx>p</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>p</span> <span class=p>=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>p</span> <span class=o>==</span> <span class=nx>expunged</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//read⾥ 将标记为expunge的更新为nil
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>entry</span><span class=p>)</span> <span class=nf>unexpungeLocked</span><span class=p>()</span> <span class=p>(</span><span class=nx>wasExpunged</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>CompareAndSwapPointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>,</span> <span class=nx>expunged</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//更新entry
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>entry</span><span class=p>)</span> <span class=nf>storeLocked</span><span class=p>(</span><span class=nx>i</span> <span class=o>*</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>atomic</span><span class=p>.</span><span class=nf>StorePointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>e</span><span class=p>.</span><span class=nx>p</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>因此，每次操作先检查read，因为read 并发安全，性能好些；read不满⾜，则加锁检查dirty，⼀旦是新的键值，dirty会被read更新。</p><p>Load⽅法:</p><p>Load⽅法是⼀个加载⽅法，查找key。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>Load</span><span class=p>(</span><span class=nx>key</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>value</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>//因read只读，线程安全，先查看是否满⾜条件
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>read</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=nx>readOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=c1>//如果read没有，并且dirty有新数据，那从dirty中查找，由于dirty是普通map，线程不安全，这个时候⽤
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>到互斥锁了</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>read</span><span class=p>.</span><span class=nx>amended</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=c1>// 双重检查
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>read</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Load</span><span class=p>().(</span><span class=nx>readOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=p>=</span> <span class=nx>read</span><span class=p>.</span><span class=nx>m</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=c1>// 如果read中还是不存在，并且dirty中有新数据
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>read</span><span class=p>.</span><span class=nx>amended</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl> <span class=c1>// mssLocked（）函数是性能是sync.Map 性能得以保证的重要函数，⽬的讲有锁的dirty数据，
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>替换到只读线程安全的read</span><span class=err>⾥</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nf>missLocked</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=nx>e</span><span class=p>.</span><span class=nf>load</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//dirty 提升⾄read 关键函数，当misses 经过多次因为load之后，⼤⼩等于len（dirty）时候，讲dirty替换
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>到read</span><span class=err>⾥，</span><span class=nx>以此达到性能提升</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Map</span><span class=p>)</span> <span class=nf>missLocked</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>misses</span><span class=o>++</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>misses</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>return</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//原⼦操作，耗时很⼩
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=nx>m</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>readOnly</span><span class=p>{</span><span class=nx>m</span><span class=p>:</span> <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span><span class=p>})</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>dirty</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl> <span class=nx>m</span><span class=p>.</span><span class=nx>misses</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><em>sync.Map是通过冗余的两个数据结构(read、dirty),实现性能的提升。为了提升性能，load、delete、store等操作尽量使⽤只读的read；为了提⾼read的key击中概率，采⽤动态调整，将dirty数据提升为read；对于数据的删除，采⽤延迟标记删除法，只有在提升dirty的时候才删除。</em></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>文章有帮到您的话，请我喝杯奶茶吧ヾ(●´∀｀●)</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=/images/alipay.jpg>
<span>支付宝打赏</span></label>
<label class=qr-code-image for=reward><img class=image src=/images/wepay.jpg>
<span>微信打赏</span></label></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-11-07 01:50:47">更新于 2022-11-07&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href=https://github.com/kendrickcheung/begi/edit/main/content/posts/Go%e8%af%ad%e8%a8%80/%e9%9d%a2%e8%af%95/%e5%90%8e%e7%ab%af%e9%9d%a2%e8%af%95%e9%a2%98%e9%9b%8602.zh-cn.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/ data-title=【面试】后端面试题集02 data-hashtags=interview,Golang><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/ data-hashtag=interview><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/ data-title=【面试】后端面试题集02><i class="fa-brands fa-hacker-news fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/ data-title=【面试】后端面试题集02><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://kendrickcheung.github.io/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8602/ data-title=【面试】后端面试题集02><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/interview/>面试</a>,&nbsp;<a href=/tags/golang/>Go语言</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8601/ class=prev rel=prev title=【面试】后端面试题集01><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>【面试】后端面试题集01</a>
<a href=/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%8603/ class=next rel=next title=【面试】后端面试题集03>【面试】后端面试题集03<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=kendrickcheung/kendrickcheung.github.io data-repo-id=R_kgDOILbtyQ data-category=General data-category-id=DIC_kwDOILbtyc4CR5sB data-mapping=title data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.105.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.17-RC"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2021 - 2022</span><span class=author itemprop=copyrightHolder>
<a href=https://kendrickcheung.github.io/ target=_blank rel="external nofollow noopener noreferrer">Kendrick</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i>&nbsp;<span class=run-times>网站运行中 ...</span></span></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/kendrickcheung/begi title="在 GitHub 上查看源代码" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script src=/lib/lazysizes/lazysizes.min.js async defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/cell-watermark/watermark.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!0,giscus:{darkTheme:"dark_dimmed",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,enablePangu:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"2R1K9SKLQZ",algoliaIndex:"index.zh-cn",algoliaSearchKey:"4a226aa1c5c98d6859e4d1386adb2bc7",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2021-12-18T16:15:22+08:00",watermark:{content:'\u003cimg class="fixit-icon" src="/fixit.min.svg" alt="FixIt logo" /\u003e FixIt 主题',enable:!0,height:21,opacity:.0125}}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>